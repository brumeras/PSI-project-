@page "/chat/{MatchedUsername}"
@using KNOTS.Models
@using System
@using KNOTS.Services.Chat
@using KNOTS.Services.Interfaces
@using Microsoft.JSInterop
@using System.Linq
@using System.Text.Json
@using KNOTS.Services
@inject IMessageService MessageService
@inject InterfaceUserService UserService
@inject IJSRuntime JSRuntime
@implements IDisposable
@rendermode InteractiveServer

<div class="chat-container">
    <div class="chat-header">
        <div class="header-content">
            <a href="/Home" class="btn-home">Home</a>
            <h3>Chat with @MatchedUsername</h3>
        </div>
    </div>
    
    <div class="messages-container" @ref="messagesContainer">
        @if (isLoading)
        {
            <p class="loading-text">Loading...</p>
        }
        else if (messages.Any())
        {
            @foreach (var message in messages)
            {
                <div class="message @(IsSentByCurrentUser(message) ? "sent" : "received")">
                    <div class="message-content">@message.Content</div>
                    <div class="message-time">@message.SentAt.ToString("HH:mm")</div>
                </div>
            }
        }
        else
        {
            <p class="no-messages">Start the conversation...</p>
        }
    </div>
    
    <div class="input-container">
        <input @bind="messageInput" 
               @bind:event="oninput"
               @onkeydown="HandleKeyPress"
               placeholder="Type a message..."
               class="message-input"
               disabled="@isSending" />
        <button @onclick="SendMessage"
                class="send-button"
                disabled="@(string.IsNullOrWhiteSpace(messageInput) || isSending)">
            @(isSending ? "Sending..." : "Send")
        </button>
    </div>
</div>

<style>
    .chat-container {
        display: flex;
        flex-direction: column;
        height: 100vh;
        max-width: 800px;
        margin: 0 auto;
        background: white;
    }

    .chat-header {
        padding: 1rem;
        background: linear-gradient(135deg, #f888e9 0%, #bd87f8 100%);
        color: white;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .header-content {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 1rem;
    }

    .chat-header h3 {
        margin: 0;
        font-size: 1.3rem;
        flex: 1;
        text-align: center;
    }

    .btn-home {
        background: linear-gradient(135deg, #f888e9 0%, #bd87f8 100%);
        color: white;
        padding: 0.75rem 1.6rem;
        border-radius: 12px;
        text-decoration: none;
        font-weight: 700;
        transition: all 0.3s ease;
        box-shadow: 0 4px 12px rgba(248, 136, 233, 0.4);
        border: none;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        min-width: 90px;
    }

    .btn-home:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(248, 136, 233, 0.6);
        color: white;
    }

    .messages-container {
        flex: 1;
        overflow-y: auto;
        padding: 1rem;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        background: #f5f5f5;
    }

    .loading-text, .no-messages {
        text-align: center;
        color: #999;
        padding: 2rem;
        font-style: italic;
    }

    .message {
        max-width: 70%;
        padding: 0.75rem 1rem;
        border-radius: 1rem;
        word-wrap: break-word;
        animation: slideIn 0.3s ease;
    }

    @@keyframes slideIn {
        from {
            opacity: 0;
            transform: translateY(10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .message.sent {
        align-self: flex-end;
        background: linear-gradient(135deg, #f888e9 0%, #bd87f8 100%);
        color: white;
        border-bottom-right-radius: 0.25rem;
    }

    .message.received {
        align-self: flex-start;
        background: white;
        border: 1px solid #e0e0e0;
        color: #333;
        border-bottom-left-radius: 0.25rem;
    }

    .message-content {
        margin-bottom: 0.25rem;
        line-height: 1.4;
    }

    .message-time {
        font-size: 0.75rem;
        opacity: 0.7;
    }

    .input-container {
        display: flex;
        gap: 0.5rem;
        padding: 1rem;
        background: white;
        border-top: 1px solid #e0e0e0;
    }

    .message-input {
        flex: 1;
        padding: 0.75rem;
        border: 2px solid #e0e0e0;
        border-radius: 1rem;
        font-size: 1rem;
        outline: none;
        transition: border-color 0.3s;
    }

    .message-input:focus {
        border-color: #bd87f8;
    }

    .message-input:disabled {
        background: #f5f5f5;
        cursor: not-allowed;
        opacity: 0.6;
    }

    .send-button {
        padding: 0.75rem 1.5rem;
        background: linear-gradient(135deg, #f888e9 0%, #bd87f8 100%);
        color: white;
        border: none;
        border-radius: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s;
        min-width: 90px;
    }

    .send-button:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(248, 136, 233, 0.4);
    }

    .send-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
    }

    @@media (max-width: 768px) {
        .chat-container {
            max-width: 100%;
        }

        .message {
            max-width: 85%;
        }

        .chat-header h3 {
            font-size: 1.1rem;
        }
    }
</style>

@code {
    [Parameter] public string MatchedUsername { get; set; } = string.Empty;

    private List<Message> messages = new();
    private string messageInput = "";
    private string CurrentUsername = string.Empty;
    private ElementReference messagesContainer;
    private bool isLoading = true;
    private bool isSending = false;
    private bool isRefreshing = false;
    private DotNetObjectReference<ChatRazor>? dotNetRef;
    private Task? autoRefreshTask;
    private CancellationTokenSource? autoRefreshCts;
    private static int temporaryIdCounter = 0;
    private bool shouldScrollToBottom = false;
    private string? lastKnownMessageKey;
    private static readonly JsonSerializerOptions messageJsonOptions = new() { PropertyNameCaseInsensitive = true };
    
    protected override async Task OnInitializedAsync()
    {
        CurrentUsername = UserService.CurrentUser ?? string.Empty;

        if (!string.IsNullOrWhiteSpace(CurrentUsername) && !string.IsNullOrWhiteSpace(MatchedUsername))
        {
            await LoadMessages(forceScroll: true);
            StartAutoRefresh();
        }

        isLoading = false;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender)
        {
            await ScrollToBottomIfNeeded();
            return;
        }

        dotNetRef = DotNetObjectReference.Create(this);
        await JSRuntime.InvokeVoidAsync("setBlazorGameComponent", dotNetRef);

        if (!string.IsNullOrWhiteSpace(CurrentUsername))
        {
            await JSRuntime.InvokeAsync<bool>("ensureChatAndSetUsername", CurrentUsername);
        }

        await ScrollToBottomIfNeeded();
    }

    public void Dispose()
    {
        JSRuntime.InvokeVoidAsync("setBlazorGameComponent", (object?)null);
        dotNetRef?.Dispose();
        autoRefreshCts?.Cancel();
    }

    private async Task LoadMessages(bool forceScroll = false, bool detectNewMessages = false)
    {
        try
        {
            var previousKey = lastKnownMessageKey;
            var fetched = await MessageService.GetConversation(CurrentUsername, MatchedUsername);

            messages = fetched
                .OrderBy(m => m.SentAt)
                .ToList();

            lastKnownMessageKey = CreateMessageKey(messages.LastOrDefault());

            if (forceScroll || (detectNewMessages && lastKnownMessageKey != null && lastKnownMessageKey != previousKey))
            {
                shouldScrollToBottom = true;
            }

            await MessageService.MarkConversationAsRead(CurrentUsername, MatchedUsername);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading messages: {ex.Message}");
            messages = new List<Message>();
        }
    }
    
    private async Task RefreshMessages()
    {
        if (isRefreshing)
        {
            return;
        }

        isRefreshing = true;

        if (string.IsNullOrWhiteSpace(CurrentUsername) || string.IsNullOrWhiteSpace(MatchedUsername))
        {
            isRefreshing = false;
            return;
        }

        await LoadMessages(detectNewMessages: true);
        StateHasChanged();
        isRefreshing = false;
    }

    private void StartAutoRefresh()
    {
        if (autoRefreshTask != null && !autoRefreshTask.IsCompleted)
        {
            return;
        }

        autoRefreshCts?.Cancel();
        autoRefreshCts = new CancellationTokenSource();
        autoRefreshTask = RunAutoRefresh(autoRefreshCts.Token);
    }

    private async Task RunAutoRefresh(CancellationToken token)
    {
        using var timer = new PeriodicTimer(TimeSpan.FromSeconds(2));

        try
        {
            while (await timer.WaitForNextTickAsync(token))
            {
                await InvokeAsync(RefreshMessages);
            }
        }
        catch (OperationCanceledException)
        {
            // expected when disposing
        }
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(messageInput) || isSending)
            return;

        if (string.IsNullOrWhiteSpace(CurrentUsername) || string.IsNullOrWhiteSpace(MatchedUsername))
        {
            Console.WriteLine("Cannot send message without valid participants");
            return;
        }

        isSending = true;

        try
        {
            var trimmed = messageInput.Trim();
            AddOptimisticMessage(trimmed);

            var sent = await JSRuntime.InvokeAsync<bool>("sendChatMessage", MatchedUsername, trimmed);

            if (!sent)
            {
                Console.WriteLine("Error sending message via chat hub");
            }

            messageInput = string.Empty;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error sending message: {ex.Message}");
        }
        finally
        {
            isSending = false;
            StateHasChanged();
        }
    }
    
    private async Task HandleKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !e.ShiftKey)
        {
            await SendMessage();
        }
    }
    
    [JSInvokable("OnChatMessageReceived")]
    public async Task OnChatMessageReceived(string messageJson)
    {
        await HandleIncomingMessage(messageJson);
    }

    [JSInvokable("OnChatMessageSent")]
    public async Task OnChatMessageSent(string messageJson)
    {
        await HandleIncomingMessage(messageJson);
    }

    private async Task HandleIncomingMessage(string messageJson)
    {
        try
        {
            var message = System.Text.Json.JsonSerializer.Deserialize<Message>(messageJson, messageJsonOptions);
            if (message == null)
            {
                return;
            }

            var normalizedSender = Normalize(message.SenderId);
            var normalizedReceiver = Normalize(message.ReceiverId);
            var normalizedCurrent = Normalize(CurrentUsername);
            var normalizedMatch = Normalize(MatchedUsername);

            var isRelevant = (normalizedSender == normalizedCurrent && normalizedReceiver == normalizedMatch) ||
                             (normalizedSender == normalizedMatch && normalizedReceiver == normalizedCurrent);

            if (!isRelevant)
            {
                return;
            }

            RemoveMatchingPlaceholder(message);

            if (message.Id != 0 && messages.Any(m => m.Id == message.Id))
            {
                return;
            }

            messages.Add(message);
            messages = messages
                .OrderBy(m => m.SentAt)
                .ToList();
            lastKnownMessageKey = CreateMessageKey(messages.LastOrDefault());
            shouldScrollToBottom = true;

            if (normalizedReceiver == normalizedCurrent)
            {
                await MessageService.MarkConversationAsRead(CurrentUsername, MatchedUsername);
            }
            InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to handle incoming chat message: {ex.Message}");
        }
    }

    private static string Normalize(string value) => (value ?? string.Empty).Trim().ToLowerInvariant();

    private void AddOptimisticMessage(string content)
    {
        var placeholder = new Message
        {
            Id = Interlocked.Decrement(ref temporaryIdCounter),
            SenderId = CurrentUsername,
            ReceiverId = MatchedUsername,
            Content = content,
            SentAt = DateTime.Now,
            IsRead = false
        };

        messages.Add(placeholder);
        messages = messages
            .OrderBy(m => m.SentAt)
            .ToList();
        lastKnownMessageKey = CreateMessageKey(messages.LastOrDefault());
        shouldScrollToBottom = true;
        StateHasChanged();
    }

    private void RemoveMatchingPlaceholder(Message incoming)
    {
        var incomingContent = Normalize(incoming.Content);

        var placeholder = messages.FirstOrDefault(m =>
            m.Id < 0 &&
            Normalize(m.SenderId) == Normalize(CurrentUsername) &&
            Normalize(m.ReceiverId) == Normalize(MatchedUsername) &&
            Normalize(m.Content) == incomingContent);

        if (placeholder != null)
        {
            messages.Remove(placeholder);
        }
    }

    private bool IsSentByCurrentUser(Message message)
    {
        return Normalize(message.SenderId) == Normalize(CurrentUsername);
    }

    private static string? CreateMessageKey(Message? message)
    {
        if (message == null)
        {
            return null;
        }

        return $"{message.Id}-{message.SentAt:o}-{Normalize(message.SenderId)}-{Normalize(message.ReceiverId)}";
    }

    private async Task ScrollToBottomIfNeeded()
    {
        if (!shouldScrollToBottom)
        {
            return;
        }

        shouldScrollToBottom = false;

        try
        {
            await JSRuntime.InvokeVoidAsync("scrollMessagesToBottom", messagesContainer);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to scroll messages: {ex.Message}");
        }
    }
}
